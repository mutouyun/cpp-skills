# 返回值、拷贝和移动

## 1. 返回值的问题

大凡编程语言，都会有“函数”这个概念。而对于外部的调用者而言，一个函数最重要的价值往往就是它的返回值了（有副作用的函数两说）。

返回值其实应该是一个很简单的话题。当需要通过函数传递一个值出去的时候，使用返回值不是理所当然的嘛，比如说，直接通过返回值将函数的计算结果返回出去，像下面这样：

```C++
int add(int a, int b)
{
    return a + b;
}
 
int main(int argc, char* argv[])
{
    int i = add(1, 2);
    std::cout << i << std::endl;
    return 0;
}
```

不论是函数还是调用者都会身心愉悦，因为这是最自然的使用方法了。但是在C++里，通过函数返回值返回处理结果往往是一种奢侈的行为。

让我们看一个新的例子：

```C++
int main(int argc, char* argv[])
{
    std::string ss;
    std::string s1("Hello"), s2("-"), s3("World"), s4("!");
    ss = s1 + s2 + s3 + s4;
    std::cout << ss << std::endl;
    return 0;
}
```

相信有经验的C++程序员看到了都会皱眉头，良好的做法应当是使用`+=`来代替之：

```C++
int main(int argc, char* argv[])
{
    std::string ss;
    std::string s1("Hello"), s2("-"), s3("World"), s4("!");
    ss += s1 += s2 += s3 += s4;
    std::cout << ss << std::endl;
    return 0;
}
```

原因很简单，+和+=的操作符重载的实现一般而言是像这样的：

```C++
operator char*(void) const
{
    return str_;
}
 
Str& operator+=(const char* str)
{
    if (str) strcat_s(str_, 1024, str);
    return (*this);
}
 
friend Str operator+(const Str& x, const Str& y)
{
    return Str(x) += y;
}
```

注意到上面，由于`operator+`不能修改任何一个参数，所以必须构建一个临时变量`Str(x)`，并且`Str(x)`在把值传递出去之后，自身马上就销毁了。外面负责接收的变量只能得到并复制一遍`Str(x)`，于是一个简单的返回值就造成了两次`x`的拷贝。当像上文“`ss = s1 + s2 + s3 + s4`”这样连加的时候，拷贝就会像击鼓传花一样，在每一次+调用处发生。

我们也不可能把`operator+`的返回值像`operator+=`一样用引用或指针来代替，否则外部得到的引用将是一个悬空引用，无法通过它拿到处理后的数据。

为了说明问题，我们可以写一个简单的例子来看看这样赋值到底会有多大的损耗：

```C++
// Using C++ 98/03
class Str
{
protected:
    char* str_;
 
public:
    Str(void)                       // 默认的构造函数，什么也不做
        : str_(nullptr)
    {}
 
    Str(const char* rhs)            // 普通赋值构造函数
        : str_(nullptr)
    {
        if (!rhs) return;
        str_ = new char[1024];
        strcpy_s(str_, 1024, rhs);
        std::cout << "Str constructor " << str_ << std::endl;
    }
 
    Str(const Str& rhs)             // 拷贝构造函数
        : str_(nullptr)
    {
        if (!rhs) return;
        str_ = new char[1024];
        strcpy_s(str_, 1024, rhs.str_);
        std::cout << "Str copy constructor " << str_ << std::endl;
    }
 
    ~Str(void)                      // 析构函数
    {
        if (!str_) return;
        std::cout << "Str destructor " << str_ << std::endl;
        delete [] str_;
    }
 
    const Str& operator=(Str rhs)   // 赋值操作符重载
    {
        rhs.swap(*this);            // 使用copy-and-swap惯用法获得数据
        return (*this);             // 避免重复撰写operator=
    }
 
    void swap(Str& rhs)             // 交换算法
    {
        std::swap(str_, rhs.str_);
    }
 
    operator char*(void) const
    {
        return str_;
    }
 
    Str& operator+=(const char* rhs)
    {
        if (rhs) strcat_s(str_, 1024, rhs);
        return (*this);
    }
 
    friend Str operator+(const Str& x, const Str& y)
    {
        return Str(x) += y;
    }
};
 
int main(int argc, char* argv[])
{
    Str ss;
    Str s1("Hello"), s2("-"), s3("World"), s4("!");
    std::cout << std::endl;
 
    ss = s1 + s2 + s3 + s4;
 
    std::cout << std::endl;
    std::cout << ss << std::endl;
    std::cout << std::endl;
    return 0;
}
```

这是一个简单的Str类，包装了一个char*，并限制字符串长度为1024。程序运行之后，我们得到如下打印信息：

```
Str copy constructor Hello
Str copy constructor Hello-
Str destructor Hello-
Str copy constructor Hello-
Str copy constructor Hello-World
Str destructor Hello-World
Str copy constructor Hello-World
Str copy constructor Hello-World!
Str destructor Hello-World!
Str destructor Hello-World
Str destructor Hello-
```

连续6次拷贝构造，并且最终这些临时生成的字符串统统炸鞭炮一样噼里啪啦被销毁掉了。一次拷贝的工作是`new`一个1024的大内存块，再来一次`strcpy`。连续的构造-拷贝-析构，对性能会有相当大的影响。所以尽量选择`+=`其实是不得已而为之的事情。

同样的道理，我们也很少写`Str toStr(int i)`，取而代之是`void toStr(int i, Str& s)`。为了避免返回值的性能问题，我们不得不牺牲掉代码的优雅，用蹩脚的参数来解决。

除了性能之外，对象的所有权也是一个问题。