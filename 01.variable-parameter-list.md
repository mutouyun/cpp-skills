# 任意个数的参数传递

## 1. 继承自C语言的可变参数列表

大家一定都用过`printf`，这是C语言里常用的格式化输出函数。这个函数的定义看起来像这样：
```C++
int printf(const char * format, ...);
```
函数的第二个参数“`...`”，即为可变参数列表（Variable Parameter List）。C++也继承了C的这一特征，它可以让一个函数接受任意多个参数，但同时也具有很多不便和限制。

例如，我们定义一个计算多个数字相加的函数`sum`，使用可变参数列表的定义方式如下：
```C++
#include <iostream>
#include <stdarg.h>

int sum(int num, ...)
{
    /* 定义参数列表 */
    va_list valist;

    /* 为 num 个参数初始化 valist */
    va_start(valist, num);

    /* 访问所有赋给 valist 的参数 */
    int ret = 0;
    for (int i = 0; i < num; ++i)
    {
        ret += va_arg(valist, int);
    }

    /* 清理内存 */
    va_end(valist);

    return ret;
}

int main(void)
{
    std::cout << "2 + 3 = " << sum(2, 2, 3) << std::endl;
    std::cout << "2 + 3 + 4 = " << sum(3, 2, 3, 4) << std::endl;
}
```
可以看出，C/C++的可变参数列表有着如下一些限制：

1. 可变参数列表之前，至少需要一个普通参数；

2. 仅通过可变参数列表自身，无法得到可变参数的个数。比如上面的例子里，我们必须在第一个参数`num`中写入正确的变参个数；

3. 变参传入后无法知道参数的类型。

上面的`sum`，如果写成这样：
```C++
int sum(...) { /* ... */ }
```
那么通过可变参数列表传递的内容就无法正常的获取了。同样的，参数传递的个数虽然是任意的，但参数的类型却被限制为`int`，若传入的参数类型不同，`sum`就有可能出错。


由于上面的这三点限制，C/C++中的可变参数列表应用并不广泛。众所周知的一个经典应用就是C语言里的`printf`函数了。

到了C++里，考虑到类型安全，以及自动的参数类型解析和匹配，C++用`cout`对象代替了`printf`，可变参数列表的存在感进一步减弱了。甚至到了后来，可变参数列表变成了泛型和模板元编程中运用SFINAE的一种工具和手段，而不是实现一个变参函数。

## 2. 可变参数列表的改进和替代

针对可变参数列表的限制和劣势，我们有多种手段对其进行改进；同时，也有不少替代方案来实现任意个数的参数传递。

### 2.1 使用宏（macro）

我们可以通过一个宏对常规的可变参数列表进行包装：
```C++
#define PP_FILTER__(   _1,  _2,  _3,  _4,  _5,  _6,  _7,  _8,  _9,  _10, \
                       _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, \
                       _N, ...) _N
#define PP_NUMBER__()  20,  19,  18,  17,  16,  15,  14,  13,  12,  11, \
                       10,   9,   8,   7,   6,   5,   4,   3,   2,   1

#define PP_VA_(...)      __VA_ARGS__ /* Expand __VA_ARGS__ */
#define PP_HELPER_(...)  PP_VA_(PP_FILTER__(__VA_ARGS__))
#define PP_COUNT_(...)   PP_HELPER_(__VA_ARGS__, PP_NUMBER__())

#define PP_SUM(...) sum(PP_COUNT_(__VA_ARGS__), __VA_ARGS__)

int sum(int num, ...)
{
    // ...
}

int main(void)
{
    std::cout << "2 + 3 = " << PP_SUM(2, 3) << std::endl;
    std::cout << "2 + 3 + 4 = " << PP_SUM(2, 3, 4) << std::endl;
}
```
如上，`PP_SUM`具备了自动计算参数个数的能力，使用起来也稍显友好。缺点则是我们不得不加上一堆晦涩难懂的宏作为函数`sum`的包装；并且参数的个数计算也被限制在20以内。

一般来说，20个参数已经足够了。如果希望一次传递更多参数，可以调整`PP_FILTER__`和`PP_NUMBER__`宏来实现更多的参数支持。但不得不说，存在上限的“任意”个数总让人心里不舒坦；更何况此方法仍然无法解决参数类型的限制问题。

### 2.2 使用函数或操作符重载

在C++中，我们更倾向于希望参数在传递过程中保留它的一切属性。很显然，单纯的可变参数列表丢失了太多东西；而类似`printf`那样使用一个小的子语言（format specifiers）来定义参数的类型和细节，则无疑让使用者负担了额外的工作，并且也难以对类型的正确性做静态或动态检查。

因此，C++的做法是使用一些特殊的操作符重载，结合对象自身的状态存储，来完成任意个数的参数传递。

如C++中`printf`的替代对象`cout`：
```C++
#include <iostream>

int main(void)
{
    std::cout << "2 + 3 = " << 5 << std::endl;
    std::cout << "2 + 3 + 4 = " << 9 << std::endl;
}
```
实际上，`cout`是一个全局变量，定义在`iostream`中，一般像这样：
```C++
typedef basic_ostream<char, char_traits<char> > ostream;
extern ostream cout;
```
而真正赋予它使用`<<`操作符输入内容的，则是一组`operator<<`重载：
```C++
template <...>
class basic_ostream : ...
{
public:
    basic_ostream& operator<<(bool _Val);
    basic_ostream& operator<<(short _Val);
    basic_ostream& operator<<(unsigned short _Val);
    basic_ostream& operator<<(int _Val);
    basic_ostream& operator<<(unsigned int _Val);
    ...
};
```
我们可以用operator()来实现类似的功能：
```C++
#include <stdio.h>

class Foo
{
public:
    template <typename T>
    explicit Foo(T a)
    {
        (*this)(a);
    }

    Foo& operator()(int a)
    {
        printf("%d", a);
        return (*this);
    }

    Foo& operator()(char c)
    {
        printf("%c", c);
        return (*this);
    }
};

int main()
{
   Foo(1)(2)('3');
   return 0;
}
```
输出：
```
123
```
上面的代码除了使用了`operator()`，同时还用了`Foo`的构造函数来模拟第一个`operator()`。

这种做法的关键在于函数返回了类对象自身的引用，因此无所谓是否是操作符重载，普通成员函数也是可以的。只是操作符重载一般看起来更简洁些。使用这个技巧，我们可以通过重载，或者template在编译期萃取出参数的类型特征，进行有针对性的算法选择。

Qt库的`QString`就使用了一组成员函数`arg`的重载来实现字符串的格式化功能（[QString Class | Qt Core 5.11](http://doc.qt.io/qt-5/qstring.html#arg-1 "QString Class | Qt Core 5.11")）：
```C++
QString i;           // current file's number
QString total;       // number of files to process
QString fileName;    // current file's name

QString status = QString("Processing file %1 of %2: %3")
                .arg(i).arg(total).arg(fileName);

QString str;
str = QString("Decimal 63 is %1 in hexadecimal")
        .arg(63, 0, 16);
// str == "Decimal 63 is 3f in hexadecimal"

QLocale::setDefault(QLocale(QLocale::English, QLocale::UnitedStates));
str = QString("%1 %L2 %L3")
        .arg(12345)
        .arg(12345)
        .arg(12345, 0, 16);
// str == "12345 12,345 3039"
```
### 2.3 多参数的断言（`assert`）宏
成员函数返回对象自身引用的技巧结合宏，可以实现一些好玩且实用的功能。比如我们都使用过`assert`函数或宏，其简单的实现类似这样：
```C++
#include <iostream>
using namespace std;

#if !defined(NDBUG)
#define assert(p) do { if (!(p)) { \
    fprintf(stderr, \
            "Assertion failed: %s\nfile: %s, line: %d\n", \
            #p, __FILE__, __LINE__); \
    abort(); \
} } while(0)
#else
#define assert(p)
#endif

int main()
{
    assert(false);
    cout << "Hello World";
    return 0;
}
```
输出：
```
Assertion failed: false
file: /tmp/340419142/main.cpp, line: 17

signal: aborted (core dumped)
```
常规的`assert`通常只能用来判断一个条件。如果同时判断多个条件，由于传递的表达式只有一条，断言失败，我们将无法直观的判断出是哪个条件失败而引发的断言。

《Modern C++ Design》的作者Andrei Alexandrescu曾经在[Dr Dobb's](http://www.drdobbs.com/ "Dr. Dobb's | Good stuff for serious developers: Programming Tools, Code, C++, Java, HTML5, Cloud, Mobile, Testing")上发布了一篇文章《[Enhancing Assertions](http://www.drdobbs.com/cpp/enhancing-assertions/184403745 "Enhancing Assertions | Dr Dobb's")》，其中使用了一个很好玩的宏技巧来实现可传递任意个数条件的断言宏。

首先，他定义了`Assert`类如下：
```C++
class Assert
{
    ...
public:
    Assert& SMART_ASSERT_A;
    Assert& SMART_ASSERT_B;
    // whatever member functions
    Assert& print_current_val(bool, const char*);
    ...
};
```
这里除了能返回自身引用的成员函数`print_current_val`之外，还额外定义了两个public的成员变量`SMART_ASSERT_A`和`SMART_ASSERT_B`，并且在初始化时让它们指向自身（`*this`）。

之后，再定义一组宏如下：
```C++
#define SMART_ASSERT_A(x) SMART_ASSERT_OP(x, B)
#define SMART_ASSERT_B(x) SMART_ASSERT_OP(x, A)
#define SMART_ASSERT_OP(x, next) \
        SMART_ASSERT_A.print_current_val((x), #x).SMART_ASSERT_ ## next
```
然后`SMART_ASSERT`宏的实现像这样：
```C++
#define SMART_ASSERT(expr) \
        if ( (expr) ) ; \
        else make_assert(#expr).print_context(__FILE__, __LINE__).SMART_ASSERT_A
```
`make_assert`会返回一个`Assert`对象，其中包含了`#expr`表达式内容的字符串；成员函数`print_context`负责打印当前断言的上下文。最后剩下`SMART_ASSERT_A`，这也是最关键的地方。

若我们像普通的`assert`一样使用这个`SMART_ASSERT`：
```C++
SMART_ASSERT(ptr != nullptr);
```
此时`SMART_ASSERT_A`为临时`Assert`对象的public成员`SMART_ASSERT_A`，正常编译且没有任何其它作用。

若我们像这样用：
```C++
SMART_ASSERT(ptr != nullptr && a == 0 && b == 0)(a)(b);
```
那么`SMART_ASSERT_A`会作为宏，被展开成`SMART_ASSERT_OP(a, B)`，之后`SMART_ASSERT_OP`再次展开，并继续处理`(b)`……完整展开后的代码看起来像这样：
```C++
SMART_ASSERT(ptr != nullptr && a == 0 && b == 0)(a)(b);
=>
if ( (ptr != nullptr && a == 0 && b == 0) ) ;
else make_assert("ptr != nullptr && a == 0 && b == 0").print_context(__FILE__, __LINE__)
    .SMART_ASSERT_A.print_current_val((a), "a")
    .SMART_ASSERT_B.print_current_val((b), "b").SMART_ASSERT_A;
```
这样，通过两组宏，和`print_current_val`，`SMART_ASSERT`实现了任意多个条件同时断言，并且可以分别打印出其中每一个条件的表达式和内容。