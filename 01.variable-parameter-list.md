# 任意个数的参数传递

## 1. 继承自C语言的可变参数列表

大家一定都用过`printf`，这是C语言里常用的格式化输出函数。这个函数的定义看起来像这样：
```C++
int printf(const char * format, ...);
```
函数的第二个参数“`...`”，即为可变参数列表（Variable Parameter List）。C++也继承了C的这一特征，它可以让一个函数接受任意多个参数，但同时也具有很多不便和限制。

例如，我们定义一个计算多个数字相加的函数`sum`，使用可变参数列表的定义方式如下：
```C++
#include <iostream>
#include <stdarg.h>

int sum(int num, ...)
{
    /* 定义参数列表 */
    va_list valist;

    /* 为 num 个参数初始化 valist */
    va_start(valist, num);

    /* 访问所有赋给 valist 的参数 */
    int ret = 0;
    for (int i = 0; i < num; ++i)
    {
        ret += va_arg(valist, int);
    }

    /* 清理内存 */
    va_end(valist);

    return ret;
}

int main(void)
{
    std::cout << "2 + 3 = " << sum(2, 2, 3) << std::endl;
    std::cout << "2 + 3 + 4 = " << sum(3, 2, 3, 4) << std::endl;
}
```
可以看出，C/C++的可变参数列表有着如下一些限制：

1. 可变参数列表之前，至少需要一个普通参数；

2. 仅通过可变参数列表自身，无法得到可变参数的个数。比如上面的例子里，我们必须在第一个参数`num`中写入正确的变参个数；

3. 变参传入后无法知道参数的类型。

上面的`sum`，如果写成这样：
```C++
int sum(...) { /* ... */ }
```
那么通过可变参数列表传递的内容就无法正常的获取了。同样的，参数传递的个数虽然是任意的，但参数的类型却被限制为`int`，若传入的参数类型不同，`sum`就有可能出错。


由于上面的这三点限制，C/C++中的可变参数列表应用并不广泛。众所周知的一个经典应用就是C语言里的`printf`函数了。

到了C++里，考虑到类型安全，以及自动的参数类型解析和匹配，C++用`cout`对象代替了`printf`，可变参数列表的存在感进一步减弱了。甚至到了后来，可变参数列表变成了泛型和模板元编程中运用SFINAE的一种工具和手段，而不是实现一个变参函数。

## 2. 可变参数列表的改进和替代

针对可变参数列表的限制和劣势，我们有多种手段对其进行改进；同时，也有不少替代方案来实现任意个数的参数传递。

### 2.1 使用宏（macro）

我们可以通过一个宏对常规的可变参数列表进行包装：
```C++
#define PP_FILTER__(   _1,  _2,  _3,  _4,  _5,  _6,  _7,  _8,  _9,  _10, \
                       _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, \
                       _N, ...) _N
#define PP_NUMBER__()  20,  19,  18,  17,  16,  15,  14,  13,  12,  11, \
                       10,   9,   8,   7,   6,   5,   4,   3,   2,   1

#define PP_VA_(...)      __VA_ARGS__ /* Expand __VA_ARGS__ */
#define PP_HELPER_(...)  PP_VA_(PP_FILTER__(__VA_ARGS__))
#define PP_COUNT_(...)   PP_HELPER_(__VA_ARGS__, PP_NUMBER__())

#define PP_SUM(...) sum(PP_COUNT_(__VA_ARGS__), __VA_ARGS__)

int sum(int num, ...)
{
    // ...
}

int main(void)
{
    std::cout << "2 + 3 = " << PP_SUM(2, 3) << std::endl;
    std::cout << "2 + 3 + 4 = " << PP_SUM(2, 3, 4) << std::endl;
}
```
如上，`PP_SUM`具备了自动计算参数个数的能力，使用起来也稍显友好。缺点则是我们不得不加上一堆晦涩难懂的宏作为函数`sum`的包装；并且参数的个数计算也被限制在20以内。

一般来说，20个参数已经足够了。如果希望一次传递更多参数，可以调整`PP_FILTER__`和`PP_NUMBER__`宏来实现更多的参数支持。但不得不说，存在上限的“任意”个数总让人心里不舒坦；更何况此方法仍然无法解决参数类型的限制问题。

### 2.2 使用函数或操作符重载

在C++中，我们更倾向于希望参数在传递过程中保留它的一切属性。很显然，单纯的可变参数列表丢失了太多东西；而类似`printf`那样使用一个小的子语言（format specifiers）来定义参数的类型和细节，则无疑让使用者负担了额外的工作，并且也难以对类型的正确性做静态或动态检查。

因此，C++的做法是使用一些特殊的操作符重载，结合对象自身的状态存储，来完成任意个数的参数传递。

如C++中`printf`的替代对象`cout`：
```C++
#include <iostream>

int main(void)
{
    std::cout << "2 + 3 = " << 5 << std::endl;
    std::cout << "2 + 3 + 4 = " << 9 << std::endl;
}
```
实际上，`cout`是一个全局变量，定义在`iostream`中，一般像这样：
```C++
typedef basic_ostream<char, char_traits<char> > ostream;
extern ostream cout;
```
而真正赋予它使用`<<`操作符输入内容的，则是一组`operator<<`重载：
```C++
template <...>
class basic_ostream : ...
{
public:
    basic_ostream& operator<<(bool _Val);
    basic_ostream& operator<<(short _Val);
    basic_ostream& operator<<(unsigned short _Val);
    basic_ostream& operator<<(int _Val);
    basic_ostream& operator<<(unsigned int _Val);
    ...
};
```
我们可以用operator()来实现类似的功能：
```C++
#include <stdio.h>

class Foo
{
public:
    template <typename T>
    explicit Foo(T a)
    {
        (*this)(a);
    }

    Foo& operator()(int a)
    {
        printf("%d", a);
        return (*this);
    }

    Foo& operator()(char c)
    {
        printf("%c", c);
        return (*this);
    }
};

int main()
{
   Foo(1)(2)('3');
   return 0;
}
```
输出：
```
123
```
上面的代码除了使用了`operator()`，同时还用了`Foo`的构造函数来模拟第一个`operator()`。

这种做法的关键在于函数返回了类对象自身的引用，因此无所谓是否是操作符重载，普通成员函数也是可以的。只是操作符重载一般看起来更简洁些。使用这个技巧，我们可以通过重载，或者template在编译期萃取出参数的类型特征，进行有针对性的算法选择。

Qt库的`QString`就使用了一组成员函数`arg`的重载来实现字符串的格式化功能（[QString Class | Qt Core 5.11](http://doc.qt.io/qt-5/qstring.html#arg-1 "QString Class | Qt Core 5.11")）：
```C++
QString i;           // current file's number
QString total;       // number of files to process
QString fileName;    // current file's name

QString status = QString("Processing file %1 of %2: %3")
                .arg(i).arg(total).arg(fileName);

QString str;
str = QString("Decimal 63 is %1 in hexadecimal")
        .arg(63, 0, 16);
// str == "Decimal 63 is 3f in hexadecimal"

QLocale::setDefault(QLocale(QLocale::English, QLocale::UnitedStates));
str = QString("%1 %L2 %L3")
        .arg(12345)
        .arg(12345)
        .arg(12345, 0, 16);
// str == "12345 12,345 3039"
```
### 2.3 多参数的断言（`assert`）宏
成员函数返回对象自身引用的技巧结合宏，可以实现一些好玩且实用的功能。比如我们都使用过`assert`函数或宏，其简单的实现类似这样：
```C++
#include <iostream>
using namespace std;

#if !defined(NDBUG)
#define assert(p) do { if (!(p)) { \
    fprintf(stderr, \
            "Assertion failed: %s\nfile: %s, line: %d\n", \
            #p, __FILE__, __LINE__); \
    abort(); \
} } while(0)
#else
#define assert(p)
#endif

int main()
{
    assert(false);
    cout << "Hello World";
    return 0;
}
```
输出：
```
Assertion failed: false
file: /tmp/340419142/main.cpp, line: 17

signal: aborted (core dumped)
```
常规的`assert`通常只能用来判断一个条件。如果同时判断多个条件，由于传递的表达式只有一条，断言失败，我们将无法直观的判断出是哪个条件失败而引发的断言。

《Modern C++ Design》的作者Andrei Alexandrescu曾经在[Dr Dobb's](http://www.drdobbs.com/ "Dr. Dobb's | Good stuff for serious developers: Programming Tools, Code, C++, Java, HTML5, Cloud, Mobile, Testing")上发布了一篇文章《[Enhancing Assertions](http://www.drdobbs.com/cpp/enhancing-assertions/184403745 "Enhancing Assertions | Dr Dobb's")》，其中使用了一个很好玩的宏技巧来实现可传递任意个数条件的断言宏。

首先，他定义了`Assert`类如下：
```C++
class Assert
{
    ...
public:
    Assert& SMART_ASSERT_A;
    Assert& SMART_ASSERT_B;
    // whatever member functions
    Assert& print_current_val(bool, const char*);
    ...
};
```
这里除了能返回自身引用的成员函数`print_current_val`之外，还额外定义了两个public的成员变量`SMART_ASSERT_A`和`SMART_ASSERT_B`，并且在初始化时让它们指向自身（`*this`）。

之后，再定义一组宏如下：
```C++
#define SMART_ASSERT_A(x) SMART_ASSERT_OP(x, B)
#define SMART_ASSERT_B(x) SMART_ASSERT_OP(x, A)
#define SMART_ASSERT_OP(x, next) \
        SMART_ASSERT_A.print_current_val((x), #x).SMART_ASSERT_ ## next
```
然后`SMART_ASSERT`宏的实现像这样：
```C++
#define SMART_ASSERT(expr) \
        if ( (expr) ) ; \
        else make_assert(#expr).print_context(__FILE__, __LINE__).SMART_ASSERT_A
```
`make_assert`会返回一个`Assert`对象，其中包含了`#expr`表达式内容的字符串；成员函数`print_context`负责打印当前断言的上下文。最后剩下`SMART_ASSERT_A`，这也是最关键的地方。

若我们像普通的`assert`一样使用这个`SMART_ASSERT`：
```C++
SMART_ASSERT(ptr != nullptr);
```
此时`SMART_ASSERT_A`为临时`Assert`对象的public成员`SMART_ASSERT_A`，正常编译且没有任何其它作用。

若我们像这样用：
```C++
SMART_ASSERT(ptr != nullptr && a == 0 && b == 0)(a)(b);
```
那么`SMART_ASSERT_A`会作为宏，被展开成`SMART_ASSERT_OP(a, B)`，之后`SMART_ASSERT_OP`再次展开，并继续处理`(b)`……完整展开后的代码看起来像这样：
```C++
SMART_ASSERT(ptr != nullptr && a == 0 && b == 0)(a)(b);
=>
if ( (ptr != nullptr && a == 0 && b == 0) ) ;
else make_assert("ptr != nullptr && a == 0 && b == 0").print_context(__FILE__, __LINE__)
    .SMART_ASSERT_A.print_current_val((a), "a")
    .SMART_ASSERT_B.print_current_val((b), "b").SMART_ASSERT_A;
```
这样，通过两组宏，和`print_current_val`，`SMART_ASSERT`实现了任意多个条件同时断言，并且可以分别打印出其中每一个条件的表达式和内容。

## 3. C++11的可变参数模板（Variadic Templates）

从C++11开始，我们可以定义一个这样的类模板：

```C++
template <typename... Args>
class Foo { ... };
```
或者，一个像这样的函数模板：
```C++
template <typename... Args>
void func(Args... params) { printf(params...); }
```
这样的模板被称之为可变参数模板（Variadic Templates），其中`typename... Args`被称为模板参数包（Template parameter pack），`Args... params`被称为函数参数包（Function parameter pack），`params...`被称为模板参数展开（Parameter pack expansion）。

有了`template`，我们自然可以完整的保留参数的类型，限定符（qualifier）等信息，`...`也被赋予了新的含义。在C语言的可变参数列表里，我们需要通过`va_list`和`va_start`拿到参数列表的头部，并通过循环逐步获得列表的每一项内容。而可变参数模板则和它完全不同。`Args... params`被称为参数包，而非参数列表，只因为`params`确实无法像列表一样通过循环来迭代每一项的内容；通过`params...`，只能一口气展开所有传入的参数。

我们来看一组例子（from [Parameter pack(since C++11) - cppreference.com](https://en.cppreference.com/w/cpp/language/parameter_pack "Parameter pack(since C++11) - cppreference.com")）：
```C++
f(&args...); // expands to f(&E1, &E2, &E3)
f(n, ++args...); // expands to f(n, ++E1, ++E2, ++E3);
f(++args..., n); // expands to f(++E1, ++E2, ++E3, n);
f(const_cast<const Args*>(&args)...);
// f(const_cast<const E1*>(&X1), const_cast<const E2*>(&X2), const_cast<const E3*>(&X3))
f(h(args...) + args...); // expands to 
// f(h(E1,E2,E3) + E1, h(E1,E2,E3) + E2, h(E1,E2,E3) + E3)
```
一般来说，`params...`是无法被展开成一个可供迭代的列表的。当然，我们可以这样写：
```C++
template <typename... Args>
void func(Args... params)
{
    for (auto v : { params... })
    {
        std::cout << v;
    }
}
```
如上，`{ params... }`在C++中被称为brace-init-list，可以通过它将展开后的参数包逐项迭代。但这种用法很不“[Modern C++](http://www.modernescpp.com/index.php/what-is-modern-c "What is Modern C++? - ModernesCpp.com")”，代码的效率也不是最好的。在这里，我们应该用一些函数式编程的思想来使用它。

### 3.1 可变参数模板的基本用法

我们先来讨论下可变参数函数模板。

形如
```C++
template <typename... Args>
void func(Args... params) { /*...*/ }
```
的函数模板，参数包是不方便直接使用的。那么我们不妨试着定义下面这个函数：
```C++
template <typename Arg, typename... Args>
void func(Arg p1, Args... last) { /*...*/ }
```
现在，我们有了一个能够将参数列表分为两部分的函数，其中第一部分是列表的第一个参数，而另一部分则是剩下的所有参数组成的参数包。当外部如`func(1, 2, 3, 4)`这样调用时，`p1`将等于1，`last`则为`{ 2, 3, 4 }`。

有了这个函数之后，事情变得简单起来。我们只需要通过递归不停地将第一个参数解出来，并给递归增加终止条件就好了：
```C++
void func(void)
{
    // Do Nothing.
}

template <typename Arg>
void func(Arg p1)
{
    std::cout << p1;
}

template <typename Arg, typename... Args>
void func(Arg p1, Args... last)
{
    std::cout << p1;
    func(last...);
}
```
这里的基本思想是：

1. 通过函数重载将参数列表的形式归类（代替`if-else`区分参数包的模式）

2. 通过递归实现参数包的逐项展开（代替`for/while`循环对参数进行逐项处理）

